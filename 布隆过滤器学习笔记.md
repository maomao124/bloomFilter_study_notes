# 布隆过滤器

## 什么是布隆过滤器？

布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。



![image-20230227194114589](img/布隆过滤器学习笔记/image-20230227194114589.png)



位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。

总结：**一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。**







## 原理介绍

**当一个元素加入布隆过滤器中的时候，会进行如下操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。



**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。



![image-20230227194302544](img/布隆过滤器学习笔记/image-20230227194302544.png)





当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。

如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

**不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。**

综上，我们可以得出：**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**





## 布隆过滤器使用场景

1. 判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。
2. 去重：比如爬给定网址的时候对已经爬取过的 URL 去重。









## Guava 布隆过滤器

引入 Guava 的依赖：

```xml
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>28.0-jre</version>
        </dependency>
```





```java
package mao;

import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

/**
 * Project name(项目名称)：布隆过滤器
 * Package(包名): mao
 * Class(类名): GuavaBloomFilter
 * Author(作者）: mao
 * Author QQ：1296193245
 * GitHub：https://github.com/maomao124/
 * Date(创建日期)： 2023/2/27
 * Time(创建时间)： 20:01
 * Version(版本): 1.0
 * Description(描述)： 无
 */

public class GuavaBloomFilter
{
    public static void main(String[] args)
    {
        //布隆过滤器对象，创建最多存放最多2000个整数的布隆过滤器，误判率为0.01
        BloomFilter<Integer> bloomFilter = BloomFilter.create(
                Funnels.integerFunnel(), 2000, 0.01);

        //判断是否存在
        System.out.println(bloomFilter.mightContain(100));
        System.out.println(bloomFilter.mightContain(101));
        System.out.println(bloomFilter.mightContain(102));

        //设置值
        bloomFilter.put(100);
        bloomFilter.put(101);
        bloomFilter.put(102);

        //判断是否存在
        System.out.println(bloomFilter.mightContain(100));
        System.out.println(bloomFilter.mightContain(101));
        System.out.println(bloomFilter.mightContain(102));
        System.out.println(bloomFilter.mightContain(103));
    }
}
```



运行结果：

```sh
false
false
false
true
true
true
false
```







```java
package mao;

import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

/**
 * Project name(项目名称)：布隆过滤器
 * Package(包名): mao
 * Class(类名): GuavaBloomFilter2
 * Author(作者）: mao
 * Author QQ：1296193245
 * GitHub：https://github.com/maomao124/
 * Date(创建日期)： 2023/2/27
 * Time(创建时间)： 20:12
 * Version(版本): 1.0
 * Description(描述)： 测试布隆过滤器误差
 */

public class GuavaBloomFilter2
{
    public static void main(String[] args)
    {
        testGuavaBloomFilter(10000, 0.01);
        testGuavaBloomFilter(10000, 0.02);
        testGuavaBloomFilter(10000, 0.05);
        testGuavaBloomFilter(10000, 0.1);
        testGuavaBloomFilter(10000, 0.5);

        System.out.println("------");
        testGuavaBloomFilter(3000, 0.01);
        testGuavaBloomFilter(3000, 0.02);
        testGuavaBloomFilter(3000, 0.05);
        testGuavaBloomFilter(3000, 0.1);
        testGuavaBloomFilter(3000, 0.5);

        System.out.println("------");
        testGuavaBloomFilter(2000, 0.01);
        testGuavaBloomFilter(2000, 0.02);
        testGuavaBloomFilter(2000, 0.05);
        testGuavaBloomFilter(2000, 0.1);
        testGuavaBloomFilter(2000, 0.5);

        System.out.println("------");
        testGuavaBloomFilter(1000, 0.01);
        testGuavaBloomFilter(1000, 0.02);
        testGuavaBloomFilter(1000, 0.05);
        testGuavaBloomFilter(1000, 0.1);
        testGuavaBloomFilter(1000, 0.5);
        testGuavaBloomFilter(1000, 0.005);
        testGuavaBloomFilter(1000, 0.001);
        testGuavaBloomFilter(1000, 0.0001);

        System.out.println("------");
        testGuavaBloomFilter(500, 0.01);
        testGuavaBloomFilter(500, 0.02);
        testGuavaBloomFilter(500, 0.05);
        testGuavaBloomFilter(500, 0.1);
        testGuavaBloomFilter(500, 0.5);
        testGuavaBloomFilter(500, 0.005);
        testGuavaBloomFilter(500, 0.001);
        testGuavaBloomFilter(500, 0.0001);

        System.out.println("------");
        testGuavaBloomFilter(200, 0.01);
        testGuavaBloomFilter(200, 0.02);
        testGuavaBloomFilter(200, 0.05);
        testGuavaBloomFilter(200, 0.1);
        testGuavaBloomFilter(200, 0.5);
        testGuavaBloomFilter(200, 0.005);
        testGuavaBloomFilter(200, 0.001);
        testGuavaBloomFilter(200, 0.0001);

        System.out.println("------");
        testGuavaBloomFilter(100, 0.01);
        testGuavaBloomFilter(100, 0.02);
        testGuavaBloomFilter(100, 0.05);
        testGuavaBloomFilter(100, 0.1);
        testGuavaBloomFilter(100, 0.5);
        testGuavaBloomFilter(100, 0.005);
        testGuavaBloomFilter(100, 0.001);
        testGuavaBloomFilter(100, 0.0001);
    }


    /**
     * 测试Guava的布隆过滤器
     *
     * @param expectedInsertions 布隆过滤器最多存放的数量
     * @param fpp                误差
     */
    public static void testGuavaBloomFilter(int expectedInsertions, double fpp)
    {
        //布隆过滤器对象，创建最多存放最多2000个整数的布隆过滤器，误判率为0.01
        BloomFilter<Integer> bloomFilter = BloomFilter.create(
                Funnels.integerFunnel(), expectedInsertions, fpp);

        //1500次循环
        for (int i = 0; i < 1500; i++)
        {
            if (i % 3 == 0)
            {
                continue;
            }
            //将i的值% 3 不等于 0 的值放进去
            bloomFilter.put(i);
        }

        //存在的计数
        int count = 0;
        //统计
        for (int i = 0; i < 1500; i++)
        {
            //判断是否存在
            boolean b = bloomFilter.mightContain(i);
            //System.out.println(i + " --> " + b);
            //可能存在
            if (b)
            {
                count++;
            }
        }
        System.out.println("最大数量：" + expectedInsertions + "  误差：" + fpp);
        System.out.println("预期结果：1000，最终结果：" + count);
        System.out.println();
    }
}
```





运行结果：

```sh
最大数量：10000  误差：0.01
预期结果：1000，最终结果：1000

最大数量：10000  误差：0.02
预期结果：1000，最终结果：1000

最大数量：10000  误差：0.05
预期结果：1000，最终结果：1000

最大数量：10000  误差：0.1
预期结果：1000，最终结果：1000

最大数量：10000  误差：0.5
预期结果：1000，最终结果：1030

------
最大数量：3000  误差：0.01
预期结果：1000，最终结果：1000

最大数量：3000  误差：0.02
预期结果：1000，最终结果：1000

最大数量：3000  误差：0.05
预期结果：1000，最终结果：1001

最大数量：3000  误差：0.1
预期结果：1000，最终结果：1001

最大数量：3000  误差：0.5
预期结果：1000，最终结果：1095

------
最大数量：2000  误差：0.01
预期结果：1000，最终结果：1000

最大数量：2000  误差：0.02
预期结果：1000，最终结果：1000

最大数量：2000  误差：0.05
预期结果：1000，最终结果：1002

最大数量：2000  误差：0.1
预期结果：1000，最终结果：1013

最大数量：2000  误差：0.5
预期结果：1000，最终结果：1137

------
最大数量：1000  误差：0.01
预期结果：1000，最终结果：1006

最大数量：1000  误差：0.02
预期结果：1000，最终结果：1011

最大数量：1000  误差：0.05
预期结果：1000，最终结果：1021

最大数量：1000  误差：0.1
预期结果：1000，最终结果：1053

最大数量：1000  误差：0.5
预期结果：1000，最终结果：1230

最大数量：1000  误差：0.005
预期结果：1000，最终结果：1000

最大数量：1000  误差：0.001
预期结果：1000，最终结果：1001

最大数量：1000  误差：1.0E-4
预期结果：1000，最终结果：1000

------
最大数量：500  误差：0.01
预期结果：1000，最终结果：1075

最大数量：500  误差：0.02
预期结果：1000，最终结果：1106

最大数量：500  误差：0.05
预期结果：1000，最终结果：1128

最大数量：500  误差：0.1
预期结果：1000，最终结果：1175

最大数量：500  误差：0.5
预期结果：1000，最终结果：1375

最大数量：500  误差：0.005
预期结果：1000，最终结果：1060

最大数量：500  误差：0.001
预期结果：1000，最终结果：1037

最大数量：500  误差：1.0E-4
预期结果：1000，最终结果：1011

------
最大数量：200  误差：0.01
预期结果：1000，最终结果：1423

最大数量：200  误差：0.02
预期结果：1000，最终结果：1438

最大数量：200  误差：0.05
预期结果：1000，最终结果：1421

最大数量：200  误差：0.1
预期结果：1000，最终结果：1442

最大数量：200  误差：0.5
预期结果：1000，最终结果：1479

最大数量：200  误差：0.005
预期结果：1000，最终结果：1399

最大数量：200  误差：0.001
预期结果：1000，最终结果：1375

最大数量：200  误差：1.0E-4
预期结果：1000，最终结果：1293

------
最大数量：100  误差：0.01
预期结果：1000，最终结果：1497

最大数量：100  误差：0.02
预期结果：1000，最终结果：1500

最大数量：100  误差：0.05
预期结果：1000，最终结果：1497

最大数量：100  误差：0.1
预期结果：1000，最终结果：1497

最大数量：100  误差：0.5
预期结果：1000，最终结果：1494

最大数量：100  误差：0.005
预期结果：1000，最终结果：1498

最大数量：100  误差：0.001
预期结果：1000，最终结果：1498

最大数量：100  误差：1.0E-4
预期结果：1000，最终结果：1481
```



当 `mightContain()` 方法返回 _true_ 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 _false_ 时，我们可以 100％确定该元素不存在于过滤器中。

